#!/usr/bin/env python
"""computes average ABX score

Computes average from csv files generated by `2_abx_score.sh` and
extract them as tables (.rst format) to be displayed in shennong
documentation

"""

import argparse
import collections
import pathlib

import joblib
import numpy as np
import pandas


Entry = collections.namedtuple(
    'Entry', ['corpus', 'task', 'features', 'params', 'score'])


def average(df, task_type):
    if task_type == 'across':
        df['context'] = df['by']
    elif task_type == 'within':
        arr = np.array([eval(by) for by in df['by']])
        df['talker'] = [e for e, f in arr]
        df['context'] = [f for e, f in arr]
    else:
        raise ValueError('Unknown task type: {0}'.format(task_type))

    del df['by']

    # aggregate on talkers
    groups = df.groupby(['context', 'phone_1', 'phone_2'], as_index=False)
    df = groups['score'].mean()
    # aggregate on contexts
    groups = df.groupby(['phone_1', 'phone_2'], as_index=False)
    df = groups['score'].mean()

    return (1 - df.mean()[0]) * 100


def compute_scores(csv_files, njobs=1):
    def _compute_score(csv):
        name = csv.stem.split('_')
        task = name[0]
        score = average(pandas.read_csv(csv, sep='\t'), task)
        return Entry(
            corpus=name[1],
            task=task,
            features=name[2],
            params='_'.join(name[3:]),
            score=score)

    entries = joblib.Parallel(n_jobs=njobs, verbose=10)(
        joblib.delayed(_compute_score)(csv) for csv in csv_files)

    return entries


def main():
    # parse command line arguments
    parser = argparse.ArgumentParser()
    parser.add_argument('data_dir', type=pathlib.Path)
    parser.add_argument('-j', '--njobs', default=1, type=int)
    args = parser.parse_args()

    # setup input / output files
    scores_file = args.data_dir / 'final_scores.txt'

    # computes averaged scores and save them to a file
    entries = compute_scores(
        (args.data_dir / 'abx').glob('*.csv'), njobs=args.njobs)
    with open(scores_file, 'w') as fout:
        for e in sorted(entries):
            fout.write('{} {} {} {} {}\n'.format(
                e.corpus, e.task, e.features, e.params, e.score))


if __name__ == '__main__':
    main()
